= ВВЕДЕНИЕ
== Наименование программы

#h(2em) Наименование программы -- "Сервис для стриминга и селфхостинга музыки. iOS-приложение".\
#h(2em) Наименование программы на английском языке -- "Service for Self-hosting and Streaming Music. iOS app".

== Документ(ы), на основании которого(ых) ведется разработка

#h(2em) Разработка ведется на основании учебного плана подготовки бакалавров по направлению 09.03.04 «Программная инженерия» и утвержденной академическим руководителем программы темы курсового проекта.

= НАЗНАЧЕНИЕ РАЗРАБОТКИ
== Функциональное назначение

#h(2em) Разрабатываемая программа предназначена для удаленного хранения и управления музыкальной библиотекой. Продукт должен предоставлять следующие функции:\
\- Добавление треков в библиотеку;\
\- Удаление треков из библиотеки;\
\- Проигрывание треков из хранилища;\
\- Проигрывание треков из сервера;\
\- Поиск треков по названию, исполнителю;\
\- Просмотр треков исполнителя;\
\- Создание плейлистов;\
\- Управление очередью воспроизведения.

== Эксплуатационное назначение

#h(2em) Основной аудиторией данного приложения являются люди, которые ценят возможность локального хранения своей музыки, стремятся к независимости от стриминговых сервисов и удобству в прослушивании треков.

== Краткая характеристика области применения программы

#h(2em) "Сервис для стриминга и селфхостинга музыки. iOS-приложение" -- это мобильное приложение, предназначенное для создания и управления персональной музыкальной библиотекой. Приложение позволяет:

#h(2em) - Хранить музыкальные треки как на устройстве пользователя, так и на сервере;\
#h(2em) - Воспроизводить аудиозаписи как в режиме онлайн со своего сервера (стриминг), так и оффлайн (локальное хранение);\
#h(2em) - Управлять музыкальным контентом с помощью интуитивно понятного интерфейса.

#h(2em) Работа направлена на создание приложения для удобного и безграничного доступа к музыкальным трекам, загруженным пользователем.

#h(2em) Работа над данным проектом направлена на создание универсального решения, предоставляющего пользователю неограниченный доступ к загруженным трекам в любое время. Продукт сочетает в себе функциональность и удобство, что делает его актуальным на фоне отсутствия аналогичных по качеству и возможностям разработок.

= ТЕХНИЧЕСКИЕ ХАРАКТЕРИСТИКИ
== Постановка задачи на разработку программы

#h(2em) Основные требования к функциональности приложения:\
#h(2em) Разрабатываемое приложение должно быть написано на языке Swift с использованием фреймворка UIKit. Работа ведется в среде Xcode. Оно обязано корректно функционировать на устройствах, работающих под управлением iOS версии 14.0 и выше. В рамках реализации проекта следует включить следующие ключевые модули:

1. Управление музыкальными композициями\
#h(2em) 1.1. Добавление треков: Возможность загрузки аудиофайлов в библиотеку для дальнейшего использования.\
#h(2em) 1.2. Удаление треков: Легкое и быстрое удаление выбранных аудиозаписей из системы.

2. Воспроизведение музыки
#h(2em) 2.1. Стриминг: Онлайн-проигрывание треков с сервера, позволяющее слушать музыку без предварительной загрузки.\
#h(2em) 2.2. Оффлайн-проигрывание: Воспроизведение ранее загруженных треков в условиях отсутствия подключения к Интернету.\
#h(2em) 2.3. Смешивание треков: Функция случайного порядка воспроизведения для создания уникального музыкального опыта.\
#h(2em) 2.4. Восстановление очереди воспроизведения: Восстановление настроенной очереди после использования режима смешивания.\
#h(2em) 2.5. Управление очередью воспроизведения: Реализация манипулирования порядком треков, добавляя новые и удаляя уже существующие треки.

3. Поиск музыки
#h(2em) 3.1. Поиск музыки среди локальных и серверных треков:\
#h(4em) - Поиск по названию композиции;\
#h(4em) - Поиск по исполнителю;\

4. Управление плейлистами
#h(2em) 4.1. Создание плейлистов: Формирование пользователем подборок треков для персонального использования.\
#h(2em) 4.2. Удаление плейлистов: Возможность удаления устаревших или неактуальных плейлистов.\
#h(2em) 4.3. Удаление трека из плейлиста: Гибкое управление содержимым плейлистов с возможностью удаления отдельных композиций.

5. Навигация
#h(2em) 5.1. Интерактивная навигация по библиотеке: Удобное перемещение по разделам и коллекциям треков.\
#h(2em) 5.2. Тулбар (нижнее меню): Эффективная система переходов между основными разделами, такими как «Главный экран», «Поиск», «Профиль».\
#h(2em) 5.3. Автоматическое сохранение изменений: Система предотвращения потери данных при добавлении, удалении аудиоконтента.

6. Настройки приложения
#h(2em) 6.1. Редактирование профиля пользователя: Позволяет пользователю изменять свои личные данные и настраивать учетную запись.\

7. Работа в режиме online
#h(2em) 7.1. Запрос и отображение данных: Вся информация о треках, исполнителях, плейлистах запрашивается и обновляется с сервера в режиме реального времени.\
#h(2em) 7.2. Синхронизация изменений: Все операции по созданию и удалению контента передаются на сервер для обеспечения актуальности базы данных.

8. Работа в режиме offline
#h(2em) 8.1. Доступ к сохраненной информации: Пользователь может работать с данными о треках, исполнителях и плейлистах, сохраненными на устройстве.\
#h(2em) 8.2. Локальное хранение изменений: Изменения, касающиеся создания и редактирования плейлистов, сохраняются локально до момента восстановления соединения с Интернетом.\
#h(2em) 8.3. Фильтрация данных для оффлайн использования: Предоставление информации о загруженных на устройство аудиофайлах с выделением исполнителей, треков и плейлистов, доступных в оффлайн режиме.\
#h(2em) 8.4. Воспроизведение локальных треков: Обеспечение возможности слушать музыку, сохраненную непосредственно на устройстве пользователя.

9. Подключение к личному серверу по http-протоколу
#h(2em) 9.1. Авторизация пользователя: Реализация системы логина и пароля для безопасного подключения к серверу селфхостинга и стриминга.\
#h(2em) Данный функционал критически важен для обеспечения приватности и защиты данных пользователя, а также для корректного взаимодействия между клиентом и сервером.

== Описание и обоснование выбора состава технических и программных средст
=== Состав технических и программных средств

#h(2em) Для работы приложения требуется следующее оборудование и программное обеспечение:\
#h(2em) - Мобильное устройство с iOS: Устройства, работающие под управлением iOS 14.0 и выше, обеспечат оптимальную производительность и поддержку всех встроенных функций.\
#h(2em) - Доступ к Интернету: Необходим для обмена данными с сервером, выполнения стриминга и синхронизации информации.

=== Обоснование выбора технических и программных средств

#h(2em) Выбор операционной системы iOS 14.0 и выше обусловлен следующими факторами:

#h(2em) Поддержка современных возможностей языка Swift, что позволяет использовать актуальные библиотеки и средства оптимизации.

#h(2em) Совместимость с фреймворками, такими как UIKit, AVFoundation и Combine, что критически важно для воспроизведения музыки и обработки данных в реальном времени.

#h(2em) Интернет-подключение необходимо для реализации функционала стриминга, а также для обеспечения взаимодействия с серверной частью приложения, обновления данных и синхронизации пользовательских изменений.

#h(2em) Фреймворк UIKit был выбран для разработки интерфейса, потому что он является одним из основных  инструментов для разработки приложений под операционную систему iOS. Если сравнивать с фреймворком SwiftUI, то UIKit имеет больше готовых функций, более поддерживаемые версии и понятную документацию.

#h(2em) Фреймворк Foundation необходим для работы с данныеми, низкоуровневыми операциями, например, загрузка музыкальных композиций. Эта библиотека является необходимой при разарботке приложений на языке Swift.

#h(2em) Фреймворк Combine нужен для работы с потоком данных, что упрощает ассинхронную работу, отображение элементов на интерфейсе, заменяет NotificationCenter и делегаты, делая разработку более удобной.

#h(2em) Фреймворк Network необходим для отслеживания подключения к сети, автоматической реакции на ее изменение. Это нужно для поддержки online-режима и перехода в режем offline.

#h(2em) Фреймворк CoreImage используется для эстетичного отображения изображений, например, для цвета заднего плана на странице артиста. Этот цвет высчитывается с помощью данной бибилиотеки, как наиболее часто встречающийся на изображении.

#h(2em) Также был выбран нативный способ разработки, потому что он позволяет полностью контролировать создание интерфейса, настраивать кастомные элементы, такие, как ячейка трека, мини-плеер, нижнее меню. Это далает отладку и дебаг более простым и удобным, чем, например, использование Storyboard.

== Описание и обоснование архитектуры программы

#h(2em) Приложение «Сервис для стриминга и селфхостинга музыки. iOS-приложение» разработано на Swift – языке программирования, признанном стандартом для iOS-разработки. Для создания приложения используется интегрированная среда Xcode, предоставляющая все необходимые инструменты и библиотеки для разработки, тестирования и отладки.

#h(2em) - UIKit – для построения пользовательского интерфейса и реализации базовой навигационной схемы.

#h(2em) - CoreImage – применяется для обработки изображений, в частности для определения основного цветового решения обложек треков.

#h(2em) - Combine – обеспечивает реактивное программирование, позволяющее эффективно обрабатывать поток данных и обновлять интерфейс в режиме реального времени.

#h(2em) - Foundation – базовый набор инструментов для работы с данными, манипуляции строками и прочими стандартными задачами.

#h(2em) - AVFoundation – фреймворк для работы с аудиоконтентом, воспроизведения и обработки медиафайлов.

#h(2em) - Network – предназначен для реализации сетевых взаимодействий, обеспечения обмена данными между приложением и сервером.

#h(2em) Взаимодействие между клиентской частью приложения и сервером осуществляется по стандартному протоколу HTTP. Это решение обеспечивает простоту интеграции, стандартизированный обмен данными и возможность дальнейшего масштабирования системы.

#h(2em) Приложение разработано с использованием архитектурного паттерна MVVM (Model-View-ViewModel) с использованием серверным слоем, что позволяет:

#h(2em) Четко разделить представление (View) и бизнес-логику (Model), обеспечивая высокую структурированность и поддерживаемость кода (Рис. 1), для решения специфических задач приложения, таких как воспроизведение музыки, получение треков и работа с сетью, используется отдельный сервисный слой, реализованный в виде менеджеров.

#figure(
  image("images/architecture.png", width: 80%), 
  caption: [Схематичное представление архитектуры проекта],
)

#h(2em) ViewModel служит прослойкой, которая осуществляет связь между интерфейсом и данными, обрабатывая пользовательские события и управляя состоянием представлений.

#h(2em) Преимущества применения данной архитектуры:

#h(2em) 1. Чистота кода: Каждая функциональная область приложения имеет свое логическое разделение, что упрощает поддержку и расширение функционала.

#h(2em) 2. Масштабируемость: Легкая интеграция новых функций без значительных изменений в существующем коде.

#h(2em) 3. Удобство тестирования: Отделение логики от представления позволяет проводить модульное тестирование отдельных компонентов.

#h(2em) 4. Упрощенная работа с асинхронными операциями: Использование Combine позволяет легко реализовывать реактивное взаимодействие, что особенно важно при работе с сетевыми запросами и потоковой передачей данных.

#h(2em) 5. Разделение ответственности: Логика работы с музыкой, сетью, навигацией, треками, плейлистами выделена в отдельные классы, что способствует чистоте кода и упрощает разработку. ViewModel фокусируется на преобразовании данных для отображения, а специализированные менеджеры -- на выполнении нужных задач.

#h(2em) 6. Повторное использование кода:
Сервисные классы можно использовать повторно в разных ViewModel.

#h(2em) Слои архитектуры:

#h(2em) 1. Model:\
#h(2em) Представляет набор классов и структур, которые хранят и управляют данными о музыкальных треках, плейлистах, исполнителях и учетных записях пользователей. Эти сущности содержат такие параметры, как идентификаторы, названия, ссылки на медиафайлы, изображения обложек и прочую информацию, необходимую для функционирования приложения.

#h(2em) Пример моделей:\
#h(4em) - TrackRsponse\
#h(4em) - QueuedTrack\
#h(4em) - PlaylistRsponse\
#h(4em) - UserResponse\

#h(2em) 2. ViewModel:\
#h(2em) Этот слой реализует бизнес-логику приложения, обрабатывает данные, поступающие из модели, и подготавливает их для отображения на экране. ViewModel отвечает за связь между Model и View, обрабатывая события пользователя (например, изменение очереди воспроизведения, добавление нового трека) и обновляя представление в соответствии с изменениями.

#h(2em) Пример ViewModel:\
#h(4em) - MyMusicViewModel\
#h(4em) - HisotryViewModel\
#h(4em) - PlayerViewModel\
#h(4em) - SearchViewModel\

#h(2em) 3. View:\
#h(2em) Отвечает за визуальное представление данных и взаимодействие с пользователем. View включает компоненты интерфейса, такие как контроллеры, виды и анимации, позволяющие пользователю получать обратную связь и удобно работать с приложением.

#h(2em) Пример View:\
#h(4em) - MyMusicViewController\
#h(4em) - HisotryViewController\
#h(4em) - PlayerViewController\
#h(4em) - SearchViewController\

#h(2em) 3. Manager:\
#h(2em) Отвечает за выполненеи специфичных функций, таких как воспроизведение треков, добавление, удаление треков, плейлистов, работа с сервером и другое. Это позволяет уменьшить бизнес-логику в ViewModel и меньше дублировать код.

#h(2em) Пример Manager:\
#h(4em) - MusicManager -- для работы с треками, полечния их, управлением\
#h(4em) - MusicPlayerManager -- для воспроизведения треков, управлением очередью\
#h(4em) - PlaylistManager -- для работы с плейлистами\
#h(4em) - NetworkManager -- для работы с сервером\
#h(4em) - UploadQueueManager -- для работы с загрузкой треков при отстутсвии подключения к серверу\

#h(2em) Эта архитектурная модель позволяет обеспечить высокое качество кода, его логичное структурирование и адаптивность к будущим требованиям, таким образом, делая продукт конкурентоспособным и удобным для конечного пользователя.

#h(2em) Применение архитектуры в проекте на примере класса MyMusic:\
#h(2em) View - MyMusicViewController\
#h(2em) ViewModel - MyMusicViewModel\
#h(2em) Model - TrackResponse\
#h(2em) Manager - MusicManager, MusicPlayerManager

#h(2em) Сравнение с другими архитектурами:

#h(2em) 1. MVC (Model-View-Controller)

#h(2em) Данная архитектура является понятной в использовании, легкой в понимании и позволяет быстро разрабатывать приложения. Но есть недостаток в виде масштабируемости и возможности перегрузки контроллеров из-за большой бизнес-логики. Поэтому данная архитектура больше подходит для небольших проектов.

#h(2em) 2. MVP (Model-View-Presenter)

#h(2em) Эта архитектура имеет ту же проблему, что и MVC, - перегрузка презентера большой бизнес-логикой, что приведет к усложнению структуры проекта. Также MVP менее удобен в масштабируемости в отличие от MVVM.

#h(2em) 3. VIPER (View-Interactor-Presenter-Entity-Router)

#h(2em) Данная архитектура имеет хорошую масштабируемость, гибкость в разработке, но она может быть избыточной для нашего проекта, что усложнит разработку и увеличит объем кода.

== Особенности функционала

=== Вход и регистрация

#h(2em) Сверху на экране входа рсаположено 2 поля: для ввода логина и пароля. У поля для пароля есть кнопка для просмотра и скрытия набранного текста точками. Ниже расположена кнопка для отправки введенных данных для аутентификации на сервере.

#h(2em) В самом низу расположена кнопка регистрации (Рис. 2).

#h(2em) На экране регистрации, аналогично экрану входа есть поля для ввода логина и пароля и кнопка регистрации, отправляющая данные на сервер. Помимо этого есть дополнительное поле для подтверждения пароля (Рис. 3).

#h(2em) Вверху слева есть кнопка возврата на экран входа в аккаунт.

#columns([
  #figure(
    image("images/login.png", width: 30%),
    caption: [Экран входа в приложение],
  ),
  #figure(
    image("images/registration.png", width: 30%),
    caption: [Экран регистрации],
  ),
])

=== Главный экран

#h(2em) На главном экране есть 4 кнопки:\
\- Переход к моей музыке;\
\- Переход к истории;\
\- Добавление треков;\
\- Создание плейлиста;\

#h(2em) Ниже рсаположены плейлисты пользователя, при нажатии на которые открывается список с треками плейлиста.

#figure(
  image("images/main.png", width: 30%), 
  caption: [Главный экран],
)

=== Поиск

#h(2em) Вверху расположена поисковая строка и кнопка поиска.

#h(2em) При вводе слова появляются треки, у которых введенное слово присутствует в названии или в имени автора. При присутствии подключения к Интернету поиск ведется на сервере, а при отсутствии -- среди сохраненных треков. При поиске могут выдаваться треки других пользователей, которые также можно прослушивать, добавлять в очередь и плейлисты.

#h(2em) При отсутствии результатов появляется сообщение об этом.

#figure(
  image("images/search.png", width: 30%), 
  caption: [Экран поиска],
)

=== Профиль

#h(2em) Отображается информация о пользователе. Есть кнопка выхода из аккаунта, перехода к настройкам и смена режима: offline и online. В online-режиме работа происходит с сервером, но при этом воспроизводимые треки загружаются в кеш. В offline-режиме вся работа идет только с загруженными треками, кроме этого, все действия, например, загрузка новых треков, удаление и другие, сохраняются в очередь обновления, которые будут воспроизведены на сервере после подключения к сети. 

#figure(
  image("images/profile.png", width: 30%), 
  caption: [Экран профиля],
)

=== Настройки

#h(2em) Есть возможность смены логина и пароля пользователя. Но при этом необходимо подтвердить существующий пароль и дважды ввести новый. Обязательно нажать на кнопку "Сохранить", чтобы отправить обновленные данные на сервер.

#figure(
  image("images/settings.png", width: 30%), 
  caption: [Экран настроек],
)

=== Моя музыка 

#h(2em) Список треков пользователя. Отображются название трека, автор и изображение. При нажатии на трек он начинает играть. При нажатии на кнопку меню трека есть выбор:\
\- Добавить в очередь\
\- Перейти к исполнителю (если несколько исполнителей, то появляется выбор конкретного артиста)\
\- Добавить в плейлист\
\- Удалить трек (если данный трек загружен пользователем), при этом необходимо подтвердить удаление\

#figure(
  image("images/my_music.png", width: 30%), 
  caption: [Экран "Моя музыка"],
)

=== История

#h(2em) Список треков, которые сохранены в кеш. Работа и функционал аналогичен странице "Моя музыка". 

#figure(
  image("images/history.png", width: 30%), 
  caption: [Экран исотрии],
)

=== Добавление трека

#h(2em) При нажатии на кнопку "Добавить трек" появляется выбор треков с устройства пользователя. Можно загрузить сразу несколько треков. 

#figure(
  image("images/add_tracks.png", width: 30%), 
  caption: [Экран добавления треков],
)

=== Создать плейлист 

#h(2em) Поле для ввода названия плейлиста и список треков моей музыки для выбора в плейлист. После нажатия на трек справа появляется галочка, сообщающая, что трек выбран. Чтобы сохранить плейлист, необходимо нажать на кнопку "Сохранить".

#figure(
  image("images/create_playlist.png", width: 30%), 
  caption: [Экран создания плейлиста],
)

=== Плейлист 

#h(2em) Отображается название плейлиста и список его треков. Работа с треками аналогична работе на экране "Моя музыка".

#figure(
  image("images/playlist.png", width: 30%), 
  caption: [Экран плейлиста],
)

=== Мини-плеер 

#h(2em) При воспроизведении треков внизу располагается мини-плеер, сообщающий о текущем треке (название трека, автор трека, изображение). Также можно поставить на паузу и воспроизвести трек при нажатии на соответствующую кнопку справа на мини-плеере (при паузе устанавливается кнпока в виде треугольника, а при воспроизведении - в виде двух вертикальных линий).

#h(2em) При свайпах мини-плеера справа налево текущий трек переключается на следующий в очереди, а при свайпе слева направо -- предыдущий трек. Если следующего или предыдушего трека нет, то ничего не происходит.

#figure(
  image("images/mini-player.png", width: 30%), 
  caption: [Экран с мини-плеером],
)

=== Плеер

#h(2em) Почти на половину экрана в верхней части расположено изображение трека (если изображения у трека нет, то устанавливется стандартное изображение в виде музыкальной ноты. Под изображением написаны название трека и его автор. При нажатии на автора осуществляется переход на страницу атвора (или выбор автора, если у трека их несколько). Ниже автора расположены кнопки управления воспроизведения:\
#h(2em) - Продолжить / Остановить - продолжение или остановка воспроизведения трека, интерактивно меняются соответственно текущей ситуации.\
#h(2em) - Предыдущий и следующий трек - воспроизводят предыдущий и следующий трек соответственно. Если предыдущего или следующего трека нет, то ничего не происходит.\
#h(2em) - "Очередь" - осуществляет переход на экран очереди.\
#h(2em) - Перемешинвание и восстановление очереди - перемешивание и восстановление очереди проигрывания треков соответственно.\
#h(2em) - Повтор трека - воспроизводит текущий трек заново после окончания. При повторном нажатии на кнопку этот режим выключется и воспроизведение становится прежним.\
#h(2em) - Скрытие плеера - закрывает экран плеера.\
#h(2em) - Прогресс-бар - отображет текущее положение воспроизведения трека, и время воспроизведения. При нажатии на ползунок прогресс-бара можно перематывать трек.

#figure(
  image("images/player.jpg", width: 30%), 
  caption: [Экран плеера],
)

=== Очередь

#h(2em) Список треков из текущей очереди воспроизведения. Функции аналогичны функциям экрана "Моя музыка", но при удалении трека он удаляется только из очереди. Есть кнопка возврата на экран плеер. Пристутствует скролинг к текущему треку при загрузке экрана, то есть при появлении экрана очереди всегда видно текущий трек.

#figure(
  image("images/queue.png", width: 30%), 
  caption: [Экран очереди],
)

=== Исполнитель

#h(2em) Есть изображение артиста и его имя. Вверху задний фон окрашен в цвет, который наиболее часто встречается на фото артиста. При этом фото артиста берется из обложки его первого трека. Ниже отображаются треки артиста, работа с которыми аналогична работе на экране "Моя музыка".

#figure(
  image("images/artist.png", width: 30%), 
  caption: [Экран исполнителя],
)

== Обоснование выбора метода организации входных и выходных данных 

#h(2em) Входные данные:\
#h(2em) Для обеспечения удобного и интуитивно понятного взаимодействия пользователя с приложением используются следующие методы ввода:\
#h(2em) 1. Жесты (тапы и свайпы):
Тапы и свайпы – это естественные жесты для мобильных устройств, позволяющие пользователям быстро ориентироваться внутри приложения. Они обеспечивают мгновенное переключение между экранами, пролистывание списков треков или перемотку аудиопотока в мини-плеере. Такой подход улучшает пользовательский опыт и делает работу с приложением более динамичной и отзывчивой.\
#h(2em) 2. Текстовые поля:
Текстовые поля позволяют пользователю вводить данные различного рода – от логина и пароля для авторизации до ввода названий плейлистов или ключевых слов для поиска музыки. Использование текстового ввода обеспечивает гибкость в работе, позволяя пользователю адаптировать приложение под свои индивидуальные потребности и обеспечивая точность ввода необходимых параметров.\
#h(2em) 3. Кнопки:
Кнопки применяются как стандартный инструмент для подтверждения действий, выбора опций или перехода между различными функциональными разделами приложения. Благодаря своей привычной форме и визуальной доступности, они значительно упрощают выполнение операций, требующих явного подтверждения, что повышает общую надежность и удобство работы с интерфейсом.\
#h(2em) 4. Данные с сервера:
Входными данными также являются данные, которые приходят с серверной части. Это такие данные, как ответы на запросы, сообщающие об успешной или неудачной попытке, данные, содержащиве информацию о треках (название, автор, изображение, медиафайл), о плейлистах (название, треки). Это позволяет корректно взаимодействовать с аккаунтом пользователя, обновлять его данные. Ответ с сервера строится в стркутуру ResponseWrapper, которая содержит сообщение об успехе / неудаче, данные и сообщение об ошибке или ее отсутствие.

#h(2em) Выходные данные:

#h(2em) Организация и визуализация выходных данных продумана таким образом, чтобы максимизировать удобство и эффективность использования приложения:

#h(2em) 1. Локальное хранение треков:
Сохранение аудиофайлов непосредственно на устройстве обеспечивает мгновенный доступ к трекам, что позволяет пользователю воспроизводить музыку без временных задержек. Локальный кэш улучшает отклик приложения, особенно в условиях отсутствия подключения к Интернету.\
#h(2em) 2. Единый стиль интерфейса:
Визуальная консистентность и соответствие заданной функциональности обеспечивают целостность и удобство работы. Пользовательский интерфейс разработан в едином стиле, что способствует легкости восприятия и снижает порог вхождения для новых пользователей.\
#h(2em) 3. Звуковой файл:
При воспроизведении треков должен быть звук, который соответствует проигрываему файлу трека.\
#h(2em) 4. Отправка данных на сервер:
На сервер отправляются метаданные треков, аудиофайлы и изображения. А также запросы на получение таких данных, как треки, плейлисты, информация о них.

#h(2em) Таким образом, выбранная организация входных и выходных данных позволяет обеспечить максимально интуитивное и эффективное взаимодействие с приложением, что полностью соответствует предъявленным требованиям к функционалу и удобству управления музыкальным контентом.

= ОЖИДАЕМЫЕ ТЕХНИКО-ЭКОНОМИЧЕСКИЕ ПОКАЗАТЕЛИ

==	Ориентировочная экономическая эффективность

#h(2em) Курсовой проект представляет собой iOS-приложение для стриминга и хранения музыки с возможностью самостоятельного размещения контента. В данном проекте не проводится расчет экономической эффективности.

== Предполагаемая потребность

#h(2em) Основной целевой аудиторией данного приложения являются пользователи, предпочитающие независимые сервисы для хранения и прослушивания музыки, где отсутствует риск удаления контента или ограничения доступа к нему. Это особенно актуально в текущих условиях, когда санкционные ограничения и законодательные меры приводят к блокировке или удалению треков определенных исполнителей на традиционных стриминговых платформах. Дополнительно, существующие решения для селфхостинга музыки зачастую страдают неудобным интерфейсом и недостаточным набором функций, необходимых для комфортного прослушивания.

#h(2em) Приложение, разработанное в рамках данного проекта, нацелено на решение этих проблем, обеспечивая:

#h(2em) 1. Надежность и стабильность:
Пользователь получает гарантированный доступ к своему музыкальному контенту без риска его удаления внешними структурами.

#h(2em) 2. Удобный интерфейс и расширенный функционал:
Интуитивно понятное управление, эффективная организация и визуализация данных позволяют пользователям наслаждаться музыкой без лишних сложностей.

#h(2em) 3. Адаптивность и масштабируемость:
Проект рассчитан на дальнейшее развитие и интеграцию дополнительных функций, что позволит расширить аудиторию и повысить качество жизни пользователей за счет нового уровня доступа к аудиоконтенту.

#h(2em) Следовательно, предлагаемый подход к организации входных и выходных данных, а также высокое качество технического исполнения приложения способствуют удовлетворению потребностей пользователей, стремящихся к независимости и удобству использования музыкальных сервисов.

== Экономические преимущества разработки по сравнению с отечественными и зарубежными аналогами

#h(2em) Чтобы оценить преимущества создаваемого приложения, было проведено сравнение его функций с возможностями аналогичных продуктов. В анализе учитывались только бесплатные версии, не требующие подписки. Подробности приведены в таблицах 1 и 2. Ссылки на приложения, с которыми проводилось сравнение, находятся в приложении "Ссылки на аналоги".

#let column_names = (
    [Яндекс Музыка],
    [Spotify],
    [ВК\ Музыка],
    [YouTube Music],
    [Apple Music],
    [*Our Project*],
)

#let plus = table.cell(
  fill: green.lighten(60%),
)[+]

#let minus = table.cell(
  fill: red.lighten(60%),
)[-]

#figure(
    caption: [Сравнение функциональных характеристик со стриминговыми сервисами],
    table(
        columns: (6cm,) + (2cm,) * column_names.len(),
        rows: (3cm, 1.5cm),
        align: center + horizon,
        table.header(
            [Функция],
            ..column_names.map(col => rotate(0deg, reflow: true, col))
        ),

        [Скачивание треков\ на устройство],   minus, 
        minus, minus, minus, minus, plus,
        [Нет рекламы], minus, minus, minus, minus, plus, plus,
        [Бесплатное прослушивание\ без ограничений], minus, minus, minus, minus, minus, plus,
        [Возможность использования в России], plus, minus, plus, minus, plus, plus,
        [Добавление своих треков], plus, minus, plus, minus, plus, plus,

        [*Итого*], [*2*], [*0*], [*2*], [*0*], [*3*], [*5*],
    )
)

#h(2em) По критериям "Скачивание треков на устройство" и "Бесплатное прослушивание без ограничений", которые значительно влияют на удобство и возможность прослушивания музыки, разрабатываемое приложение превосходит все рассмотренные стриминговые аналоги.\
Также важным критерием безграничного и комфортноо прослушвания является отсутствие рекламы, что есть только у 1 аналога - Apple Music.\
По критериям "Возможность использования в России" наш проект превосходит Spotify и YouTube Music, а это одно из необходимых условий, так как первыми основными потребителями предполагаются жители России.\
По критерию "Добавление своих треков" Spotify и YouTube Music тоже уступают, в них нельзя загрузить собственный трек и слушать его.

#let column_names2 = (
    [Black Candy],
    [Navidrome],
    [Ampache],
    [mStream],
    [*Our Project*],
)

#figure(
    caption: [Сравнение функциональных характеристик с сервисами для селфхостинга музыки],
    table(
        columns: (6cm,) + (2cm,) * column_names2.len(),
        rows: (3cm, 1.5cm),
        align: center + horizon,
        table.header(
            [Функция],
            ..column_names2.map(col => rotate(0deg, reflow: true, col))
        ),

        [Удобный интерфейс],   minus, 
        plus, minus, minus, plus,
        [Кеширование], minus, plus, plus, minus, plus,
        [Поиск треков], minus, plus, plus, minus, plus,
        [Страницы артистов], minus, plus, plus, minus, plus,
        [Наличие приложения под iOS], minus, minus, minus, minus, plus,

        [*Итого*], [*0*], [*4*], [*3*], [*0*], [*5*],
    )
)

#h(2em) Если сравнивать среди сервисов для селфхостинга, то главным оппонентом является Navidrome, но у него нет собственного приложения, предназначенного под операционную систему iOS, что предельно необходимо для работы с этой системой. По этому же критерию проигрывают остальные рассмотренные аналоги.\
Другой аналог - Ampache - проигрывает нашему проекту, потому что у него отсутствует удобный и стильный интерфейс, что может усложнять работу с приложением.\
2 других аналога - Black Candy и mStream - проигрывают по показателям "Возможность кеширования", "Поиск треков" и "Страницы артистов".

#set heading(numbering: none)
= ПРИЛОЖЕНИЕ 1. СПИСОК ИСПОЛЬЗУЕМОЙ ЛИТЕРАТУРЫ

1. ГОСТ 19.101-77: Виды программ и программных документов. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
2. ГОСТ 19.102-77: Стадии разработки. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
3. ГОСТ 19.103-77: Обозначения программ и программных документов. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
4. ГОСТ 19.104-78: Основные надписи. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
5. ГОСТ 19.105-78: Общие требования к программным документам. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
6. ГОСТ 19.106-78: Требования к программным документам, выполненным печатным способом. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
7. ГОСТ 19.201-78: Техническое задание. Требования к содержанию и оформлению. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
8. ГОСТ 19.301-79: Программа и методика испытаний. Требования к содержанию и оформлению. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
9. ГОСТ 19.401-78: Текст программы. Требования к содержанию и оформлению. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
10. ГОСТ 19.404-79: Пояснительная записка. Требования к содержанию и оформлению. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
11. ГОСТ 19.505-79: Руководство оператора. Требования к содержанию и оформлению. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
12. ГОСТ 19.603-78: Общие правила внесения изменений. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
13. ГОСТ 19.604-78: Правила внесения изменений в программные документы, выполненные печатным способом. \// Единая система программной документации. – М.: ИПК Издательство стандартов, 2001.
14. Официальная документация Swift. Электронный ресурс. URL: https://www.swift.org/documentation/ (дата обращения 10.04.25)
15. Официальная документация UIKit. Электронный ресурс. URL: https://developer.apple.com/documentation/uikit/ (дата обращения 10.04.25)

= ПРИЛОЖЕНИЕ 2. ССЫЛКИ НА АНАЛОГИ

#figure(
  table(
    columns: (70mm, 70mm),
    rows: (10mm, auto),
    align: center + horizon,
    table.header([*Приложение*], [*Ссылка*]),

    [Яндекс Музыка], [https://music.yandex.ru/],
    [Spotify], [https://www.spotify.com/],
    [ВК Музыка], [https://music.vk.com/],
    [YouTube Music], [https://music.youtube.com/],
    [Apple Music], [https://music.apple.com/],
    [Black Candy], [https://github.com/blackcandy-org/blackcandy],
    [Navidrome], [https://www.navidrome.org/],
    [Ampache], [https://ampache.org/],
    [mStream], [https://mstream.io/],

  )
)

#h(2em) Дата обращения: 05.03.25.

#set heading(numbering: none)
= ПРИЛОЖЕНИЕ 3. ТЕРМИНОЛОГИЯ

#figure(
  table(
    columns: (40mm, 140mm),
    rows: (10mm, auto),
    align: left + horizon,
    table.header([*Термин*], [*Определение*]),

    [iOS], [Операционная система Apple для мобильных устройств, включая смартфоны iPhone и планшеты iPad],
    [Swift], [Современный язык программирования от Apple для создания приложений под платформы компании.],
    [UIKit], [Фреймворк, позволяющий разрабатывать пользовательские интерфейсы для iOS-приложений.],
    [Foundation], [Базовый фреймворк, содержащий фундаментальные классы и библиотеки для работы с данными, строками, коллекциями, датами, файловой системой и сетевыми запросами в приложениях на платформе Apple.],
    [Combine], [Инструмент для реактивного программирования, упрощающий работу с асинхронными данными и событиями.],
    [Network], [Фреймворк, облегчающий выполнение сетевых запросов и контроль сетевого подключения.],
    [AVFoundation], [Средство для работы с мультимедийным контентом, включая воспроизведение, запись, обработку аудио и видео.],
    [CoreImage], [Фреймворк для обработки изображений, предоставляющий широкий спектр фильтров и инструментов для анализа и редактирования визуальных данных.],    
    [Архитектура\ проекта], [Структурное распределение компонентов программного обеспечения, определяющее взаимосвязь и взаимодействие между различными модулями приложения для достижения поставленных функциональных и нефункциональных целей.],
    [MVVM], [Архитектурный паттерн «Model-View-ViewModel», ориентированный на разделение логики приложения и представления данных.],
  )
)

#figure(
  table(
    columns: (40mm, 140mm),
    rows: (10mm, auto),
    align: left + horizon,
    table.header([*Термин*], [*Определение*]),

    [Фреймворк], [Структурированная платформа, включающая набор инструментов, библиотек и правил, разработанных для упрощения создания и управления программным обеспечением.],
    [Стриминг], [Технология непрерывной передачи аудио- или видеоконтента через сеть, при которой данные поступают и воспроизводятся в режиме реального времени, без необходимости предварительной загрузки полного файла.],
    [Селфхостинг], [Метод организации хостинга, при котором пользователь или организация самостоятельно управляют серверной частью и хранением данных, без использования сторонних облачных сервисов.]
  )
)
